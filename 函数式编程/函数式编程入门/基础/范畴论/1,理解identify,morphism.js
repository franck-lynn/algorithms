/**
 * Created by franck.lynn on 2018/11/23.
 * franck_lynn@live.cn
 * https://www.youtube.com/watch?v=O2lZkr-aAqk&index=3&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
 */
'use strict';
import R from 'ramda'    
// identify函数, 这个函数,接收一个x, 返回一个x
// identify 是一个自己到自己的映射函数, 定义这个函数的目的是
// 进行函数组合    
var identify = x => x
// 再定义一个函数 y = x * x
var square = x => x * x
// 假设square是范畴a到b的态射morphism, 
// 记作 f。g = ida, 读作f after f equal ida, (空心点)
// 定义一个范畴,可以理解为一个容器,瓶子.
// 这个瓶子里装的是一个函数
class Container {
    constructor(f){
        this.$value = f
    }
    // 瓶子里面有实例化的方法,可以实例化这个瓶子
    // 可使其成为一个真实的可用的瓶子
    static of(f){
        return new Container(f)
    }
    // 定义一个map()方法,这个方法传进一个函数fn,
    map(fn){
        // 组合这两个函数,并把组合后的函数放回瓶子
        return Container.of(
            R.compose(this.$value, fn)
        )
    }
}

// 把identify函数装进瓶子
var compose = Container.of(identify)
// 调用瓶子里的map()方法,返回一个装有组合函数的瓶子
    .map(square)

/*
通过以上定义,可以看出,这个过程没有涉及到具体的实际运算,
只是中间过程的抽象计算.也就是函数之间的抽象组合.这就是
范畴论要解决的问题.忘记具体的集合,集合里是什么元素不重要.
重要的是态射.函数描述的是一种态射.
从集合a->b,无论中间过程怎么变化,只要找到这种态射之间的
关系,总能实现从a->b的目标.中间是态射的组合过程.不涉及
具体的集合.这就是范畴.这个个人粗线的想象理解
 */
console.log(
    // 这是具体使用的范畴规则,
    // 调用瓶子里的$value值,就是一个函数.传进具体的值,
    // 总能得到一个确定的结果.这就是纯数学的函数式编程?
    compose.$value(12)
)
/*
数学上的理解
1, 假设有一函数为: f1(x) = x,
2, 另一函数为: f2(x) = x * x,
3, 组合这2个函数得: g1(x) = f2(f1(x)) = f2(x) = x * x
另一个例子:
1, 假设有一函数为: f1(x) = 2 * x + 1,
2, 另一函数为: f2(x) = x * x,
3, 组合这2个函数得: g1(x) = f2(f1(x)) 
                      = f2(2 * x + 1) 
                      = (2 * x + 1)(2 * x + 1)
进一步抽象
1, 假设有一个函数为 f, 具体定义为f(x)
2, 另一个函数为 g, 具体定义为 g(x)
3, 组合函数为c, c = compose(f, g)
   具体一些组合是: c = f(g(x))
4, 在进一步抽象过程中,具体的东西,好像说的是 x 元素不见了,
   只剩下纯函数了.利用这个特点,可以进行无限的运算.
   例如求 fibonacci 函数, 采用组合的方式构造这一函数,
   返回的仍然是一个函数.输入任意值,即可求得这个数列的值.
   而不必从1开始.
5, 东西(集合set或者其他什么)抽象成了虚无, 要用的时候,又有了.
   当然,态射是要有的.只是东西变成了虚无.这类似于因果.是一种因导致一种
   果,没有具体所指.但一旦有了具体的东西,这个因果就具体起来,否则就是抽
   象的,只有指向,从虚无指向虚无.一旦有东西.就实例化起来了.
6, 实例化后,数据只能在瓶子里进行变异,也可以流向另外的瓶子.
7, 实际使用时,要采用具体的定义,例如:f(x), g(x), f(g(x)),至于再具体
   的表达式 , 使用时也需要定义出来.
   而数据则是等到要用的时候最后定义.                         
由以上个例子可见:
1, 函数是可以放进集合的,作为态射,是一种关系的抽象,
   是两个东西的关系.至于两个东西是什么东西,忘记它.也许有
   也许没有,谁知道呢?
   category 就是一个叫东西的东西和这两个东西的关系
   (箭头->,态射,morphism)
2, category 就是这样一种强大的抽象.
*/











