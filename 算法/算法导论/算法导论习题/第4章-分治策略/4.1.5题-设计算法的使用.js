/*
使用如下算法为最大子数组问题设计一个非递归,线性时间的算法.
从数组的左边界开始,由左到右处理.
记录到目前已经处理过的最大子数组.
若已知a[0..j]的最大子数组,基于如下性质将解扩展为a[0..j+1]的最大子数组:
a[0..j+1]的最大子数组要么是a[0..j],要么是某个子数组a[i..j+1](0<=i<=j+1).
在已知a[1..j]的最大子数组的情况下,可以在线性时间内找到形如a[i..j+1]的
最大子数组.
   0   1   2   3   4    5    6   7   8    9   10  11  12  13  14  15
[ 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7 ];
假设a[0..15]的最大子数组a[0..j]
                        [ 13, -3, -25],记录下这个值,再加上一个元素比较看看
 */
function findMAxArray(a) {
    var max = Number.NEGATIVE_INFINITY;
    var sum = 0;
    for(var j=0;j<a.length;j++){
        sum = sum + a[j]; // 扩展a[0..j+1]情况
        if(sum>max) max=sum;
        // 这里还存在的情况就是当sum <= max 时
        // 再次增加时,sum可能会减小,但是再后面可能会存在一个大数.    
        else if(sum<0) sum = 0;
    }
    return max;
}
let a = [ 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7 ];
console.log(findMAxArray(a));
















