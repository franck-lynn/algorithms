/**
 * 分割算法的实现,始终使用第n-1个元素作为主元元素,
 *    [ 3, 5, 9, 6, 2, 8 ];
 *                      pivot 作为主元
 *    ⬆                       初始的指针i,起始索引 -1   
 *      ▶                    指针 j 由数组下标从低到高扫描整个数组,小于主元时 i+1 与 j 交换
 *                                                                大于主元时i不动,只有 j 自增
 *     1, [ 3, 5, 9, 6, 2, 8 ] j=0时,i+1与j交换,注意是j,第1次是3和3本身交换
 *          ⬆
 *          ▶
 *     2, [ 3, 5, 9, 6, 2, 8 ] j=1时,i+1与j交换,注意是j,第2次是本身交换
 *             ⬆
 *             ▶
 *     3, [ 3, 5, 9, 6, 2, 8 ] j=2时,j只自增,不交换
 *             ⬆
 *                ▶
 *     4, [ 3, 5, 9, 6, 2, 8 ] j=3时,i+1与j交换,注意是j,9,6交换 
 *             ⬆
 *                   ▶
 *     5, [ 3, 5, 6, 9, 2, 8 ] j=4时,i+1与j交换,注意是j,9,2交换
 *                ⬆
 *                      ▶
 *     6, [ 3, 5, 6, 2, 9, 8 ] j=5时,循环结束
 *                   ⬆
 *                         ▶
 */
/*
  主元可以理解成拦截坝;小于拦截坝的在左边,大于拦截坝的在右边.
  用j来循环,如果j元素值小于拦截坝?就把当前 i+1 元素的值与 j 调换.a[j]小,说明前面i指针后面有大的元素.
  前面如果都是小的话,就会出现自身与自身交换的情况,因为i+1 与j是同一个元素.都会自增长.
  a[j]大的话,i就停止增长了, j 继续增长,直到出现小于 主元 的情况.这时,就要把这个小的 j 与前面大于主元的元素交换一下
  
*/
function partition(a,lo,hi) {
    var pivot = a[hi];
    var i = lo - 1;
    for (var j=i+1;j<=hi;j++){
        // 如果a[j]<主元,就把i+1,把这个元素与j交换
        if (a[j]<pivot){
            i=i+1;
            var temp=a[i];
            a[i]=a[j];
            a[j]=temp;
        }
        console.log(a)
    }
    // console.log("此时的i应该是指向元素2,下标是3",i==3)
}

var a = [ 3, 5, 9, 6, 2, 8 ];
partition(a,0,a.length-1);
// console.log(a)








